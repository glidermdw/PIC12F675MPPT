program _12f675_MPPT;

{ 12F675 MPPT controller

  Copyright (C) 2015 rasberryrabbit

  This source is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or MPL 1.1
  any later version.

  This code is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  details.

  A copy of the GNU General Public License is available on the World Wide Web
  at <http://www.gnu.org/copyleft/gpl.html>. You can also obtain it by writing
  to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  MA 02111-1307, USA.
}


{$define USE_EEPROM_LM358DIFF}
{.$define USE_LM358_AUTOCAL}

const
   { 4MHz }
   PWM_MAX = 255;            // 75
   PWM_LOW = 1;

   TMR1L_LOAD=$17;
   TMR1H_LOAD=$FC;
   
   { circuit modified, 9.6mV / 3600mV * 1024 + 1, eeprom offset 0 => 04
     circuit v2 has more sensivity on current adc reading( x4 ),
     it may value 6 but 4. measuring on PIC pin 5 voltage while no loading  }
   cLM358_diff = 4;
   Inc_Pwm_Max = 10;
   adc_max_loop = 1;

var
   LED1:sbit at GP5_bit;
   PWM_SIG:sbit at GP0_bit;
   PWM_FLAG:bit;
   PWM_TICK, ON_PWM, VOL_PWM:byte;
   TICK_1000:Byte;
   LED1_tm:byte;
   adc_vol, adc_cur, offset_cur, adc_prev, adc_diff : word;
   power_prev, power_curr, power_diff : dword;
   i, LM358_diff:byte;
   flag_inc, got_max :boolean;
   Inc_pwm, eq_cnt : byte;
   vol1, vol2 : byte;

procedure Interrupt(); iv 0x0004; ics ICS_AUTO;
begin
     if T0IF_bit=1 then begin
       if PWM_FLAG=1 then begin
         ON_PWM:=VOL_PWM;
         // on
         TMR0:=255-ON_PWM;
         PWM_SIG:=0;
         PWM_FLAG:=0;
       end else begin
         // off
         TMR0:=255-PWM_MAX+ON_PWM;
         PWM_SIG:=1;
         PWM_FLAG:=1;
       end;
       T0IF_bit:=0;
     end;
end;

begin
     CMCON:=7;
     ANSEL:=%00111100;       // ADC conversion clock = fRC, AN3, AN2;

     TRISIO0_bit:=0;      // PWM
     TRISIO1_bit:=1;      // not Connected
     TRISIO2_bit:=1;      // AN2
     TRISIO4_bit:=1;      // AN3
     TRISIO5_bit:=0;      // LED

     LED1:=0;
     PWM_SIG:=1;
     PWM_FLAG:=1;
     LED1_tm:=250;
     ON_PWM:=0;
     VOL_PWM:=0;
     TICK_1000:=0;
     VCFG_bit:=1;
     CHS1_bit:=1;
     ADFM_bit:=1;

     OPTION_REG:=%01011111;        // ~4KHz @ 4MHz
     TMR0IE_bit:=1;
     
     LM358_diff:=cLM358_diff;
     {$ifdef USE_EEPROM_LM358DIFF}
     LM358_diff:=EEPROM_Read(0);
     {$endif}

     T1CKPS0_bit:=1;               // timer prescaler 1:2
     TMR1CS_bit:=0;
     TMR1L:=TMR1L_LOAD;
     TMR1H:=TMR1H_LOAD;

     adc_vol:=0;
     adc_cur:=0;
     power_curr:=0;
     vol1:=0;
     vol2:=0;

     GIE_bit:=1;                   // enable Interrupt

     TMR1ON_bit:=1;

     {$ifdef USE_LM358_AUTOCAL}
     Delay_ms(50);
     LM358_diff:=Adc_Read(2);
     {$endif}

     VOL_PWM:=PWM_LOW;
     flag_inc:=True;
     adc_prev:=0;

     while True do begin
       // LED
       if T1IF_bit=1 then begin
         TMR1H:=TMR1H_LOAD;
         TMR1L:=TMR1L_LOAD;
         T1IF_bit:=0;
         Inc(TICK_1000);
         if TICK_1000>=LED1_tm then begin
           LED1:=not LED1;
           TICK_1000:=0;
         end;
       end;
       if (VOL_PWM>=(PWM_MAX-1)) then
         LED1_tm:=64
         else if (VOL_PWM=PWM_LOW) then
           LED1_tm:=90
           else
             LED1_tm:=120;
       // save previous adc values
       power_prev:=power_curr;
       adc_prev:=adc_cur;
       // read adc value
       adc_vol:=0;
       adc_cur:=0;
       for i:=0 to adc_max_loop-1 do begin
         adc_cur:=adc_cur+ADC_Read(2);
         adc_vol:=adc_vol+ADC_Read(3);
       end;
       adc_vol:=adc_vol div adc_max_loop;
       adc_cur:=adc_cur div adc_max_loop;
       // sub op-amp offset value
       if adc_cur>LM358_diff then
         adc_cur:=adc_cur-LM358_diff
         else
           adc_cur:=0;
       //
       if adc_cur>0 then begin
         power_curr:= adc_cur * adc_vol;
         if power_curr=power_prev then begin
           {
           if Inc_pwm>1 then
             Dec(Inc_pwm);
           }
           if adc_cur>adc_prev then begin
             flag_inc:=False;
           end else
           if adc_cur<adc_prev then begin
             flag_inc:=True;
             Inc_pwm:=1;
           end else begin
             Inc_pwm:=0;
             LED1_tm:=240;
             flag_inc:=not flag_inc;
           end;
         end else begin
           if Inc_pwm<Inc_Pwm_Max then
             Inc(Inc_pwm);
           if power_curr<power_prev then begin
             { (1) ---> lowpower1 PWM
               (2) reverse direction
               (3) equal power PWM ---> low power2 PWM
             }
             vol1:=vol2;
             vol2:=VOL_PWM;
             flag_inc:=not flag_inc;
             { (4) set average PWM }
             if (vol1<>0) and (vol2<>0) then begin
               Inc_pwm:=0;
               VOL_PWM:=(vol1+vol2) div 2;
               vol2:=0;
               continue;
             end;
           end else
             vol2:=0;
         end;
       end else begin
         // no load or low current
         power_curr:=0;
         Inc_pwm:=Inc_Pwm_Max;
         flag_inc:=True;
         vol2:=0;
       end;
       // PWM
       if flag_inc then begin
         if VOL_PWM<(PWM_MAX-Inc_pwm) then begin
           VOL_PWM:=VOL_PWM+Inc_pwm;
         end else
             VOL_PWM:=PWM_MAX;
       end else begin
         if VOL_PWM>(PWM_LOW+(Inc_Pwm_Max+1-Inc_pwm)) then begin
           VOL_PWM:=VOL_PWM-(Inc_Pwm_Max+1-Inc_pwm);
         end else
             VOL_PWM:=PWM_LOW;
       end;
     end;
end.